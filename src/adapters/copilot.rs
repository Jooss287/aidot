use super::common::{
    apply_json_merge, apply_one_to_one, ensure_dir, scan_merged_section, scan_one_to_one,
};
use super::conflict::{write_with_conflict, ConflictMode};
use super::helpers::{add_suffix_before_ext, convert_frontmatter_key, strip_section_prefix};
use super::traits::{ApplyResult, PresetFile, PresetFiles, ScanResult, ToolAdapter};
use crate::error::Result;
use std::fs;
use std::path::{Path, PathBuf};

/// GitHub Copilot adapter
///
/// Converts presets to GitHub Copilot format:
/// - rules/*.md → .github/instructions/*.instructions.md
/// - memory/*.md → .github/copilot-instructions.md (appended)
/// - commands/*.md → .github/prompts/*.prompt.md
/// - agents/*.md → .github/agents/*.agent.md
/// - skills/*.ts → .github/skills/
/// - mcp/*.json → .vscode/mcp.json
pub struct CopilotAdapter {
    project_dir: PathBuf,
}

impl CopilotAdapter {
    pub fn new(project_dir: &Path) -> Self {
        Self {
            project_dir: project_dir.to_path_buf(),
        }
    }

    /// Get the .github directory path
    fn github_dir(&self) -> PathBuf {
        self.project_dir.join(".github")
    }

    /// Get the .vscode directory path
    fn vscode_dir(&self) -> PathBuf {
        self.project_dir.join(".vscode")
    }

    /// Get the copilot-instructions.md file path
    fn copilot_instructions_file(&self) -> PathBuf {
        self.github_dir().join("copilot-instructions.md")
    }

    /// Apply memory files: memory/*.md → .github/copilot-instructions.md (appended)
    fn apply_memory(
        &self,
        files: &[PresetFile],
        result: &mut ApplyResult,
        mode: &mut ConflictMode,
    ) -> Result<()> {
        if files.is_empty() {
            return Ok(());
        }

        let instructions_file = self.copilot_instructions_file();

        // Build memory content
        let mut memory_content = String::from("\n\n---\n\n## Project Context\n\n");
        for (i, file) in files.iter().enumerate() {
            if i > 0 {
                memory_content.push_str("\n\n---\n\n");
            }
            memory_content.push_str(&format!(
                "### {}\n\n",
                strip_section_prefix(&file.relative_path, "memory").replace(".md", "")
            ));
            memory_content.push_str(&file.content);
        }

        // Read existing content or create header
        let base = if instructions_file.exists() {
            fs::read_to_string(&instructions_file)?
        } else {
            String::from("# GitHub Copilot Instructions\n\n<!-- Generated by aidot -->\n")
        };
        let content = format!("{}{}", base, memory_content);

        write_with_conflict(
            &instructions_file,
            &content,
            mode,
            result,
            ".github/copilot-instructions.md",
        )?;

        Ok(())
    }
}

impl ToolAdapter for CopilotAdapter {
    fn name(&self) -> &str {
        "GitHub Copilot"
    }

    fn detect(&self) -> bool {
        self.copilot_instructions_file().exists()
            || self.github_dir().join("instructions").exists()
            || self.github_dir().exists()
            || self.vscode_dir().exists()
    }

    fn scan(&self, preset_files: &PresetFiles, _target_dir: &Path) -> ScanResult {
        let mut result = ScanResult::new();
        let github_dir = self.github_dir();

        // Rules with filename and content transforms
        let rule_fn = |name: &str, _content: &str| add_suffix_before_ext(name, "instructions");
        let rule_content_fn = |content: &str| convert_frontmatter_key(content, "globs", "applyTo");
        scan_one_to_one(
            &preset_files.rules,
            "rules",
            &github_dir.join("instructions"),
            ".github/instructions",
            &mut result,
            Some(&rule_fn),
            Some(&rule_content_fn),
        );

        // Memory → .github/copilot-instructions.md (appended)
        if !preset_files.memory.is_empty() {
            result.add_change(
                ".github/copilot-instructions.md".to_string(),
                "memory".to_string(),
                self.copilot_instructions_file().exists(),
            );
        }

        // Commands with prompt suffix
        let cmd_fn = |name: &str, _content: &str| add_suffix_before_ext(name, "prompt");
        scan_one_to_one(
            &preset_files.commands,
            "commands",
            &github_dir.join("prompts"),
            ".github/prompts",
            &mut result,
            Some(&cmd_fn),
            None,
        );

        // MCP → .vscode/mcp.json
        scan_merged_section(
            &preset_files.mcp,
            ".vscode/mcp.json",
            "mcp",
            &self.vscode_dir().join("mcp.json"),
            &mut result,
        );

        // Agents with agent suffix
        let agent_fn = |name: &str, _content: &str| add_suffix_before_ext(name, "agent");
        scan_one_to_one(
            &preset_files.agents,
            "agents",
            &github_dir.join("agents"),
            ".github/agents",
            &mut result,
            Some(&agent_fn),
            None,
        );

        // Skills (no transform)
        scan_one_to_one(
            &preset_files.skills,
            "skills",
            &github_dir.join("skills"),
            ".github/skills",
            &mut result,
            None,
            None,
        );

        result
    }

    fn apply(
        &self,
        preset_files: &PresetFiles,
        _target_dir: &Path,
        conflict_mode: &mut ConflictMode,
    ) -> Result<ApplyResult> {
        ensure_dir(&self.github_dir())?;

        let mut result = ApplyResult::new();
        let github_dir = self.github_dir();

        // Apply merged sections first (may trigger interactive prompts)
        self.apply_memory(&preset_files.memory, &mut result, conflict_mode)?;
        apply_json_merge(
            &preset_files.mcp,
            "mcp",
            &self.vscode_dir().join("mcp.json"),
            ".vscode/mcp.json",
            "servers",
            serde_json::json!({"inputs": [], "servers": {}}),
            &mut result,
            conflict_mode,
        )?;

        // 1:1 mapped sections (resolved immediately from PreResolved map)
        let rule_fn = |name: &str, _content: &str| add_suffix_before_ext(name, "instructions");
        let rule_content_fn = |content: &str| convert_frontmatter_key(content, "globs", "applyTo");
        apply_one_to_one(
            &preset_files.rules,
            "rules",
            &github_dir.join("instructions"),
            ".github/instructions",
            &mut result,
            conflict_mode,
            Some(&rule_fn),
            Some(&rule_content_fn),
        )?;

        let cmd_fn = |name: &str, _content: &str| add_suffix_before_ext(name, "prompt");
        apply_one_to_one(
            &preset_files.commands,
            "commands",
            &github_dir.join("prompts"),
            ".github/prompts",
            &mut result,
            conflict_mode,
            Some(&cmd_fn),
            None,
        )?;

        let agent_fn = |name: &str, _content: &str| add_suffix_before_ext(name, "agent");
        apply_one_to_one(
            &preset_files.agents,
            "agents",
            &github_dir.join("agents"),
            ".github/agents",
            &mut result,
            conflict_mode,
            Some(&agent_fn),
            None,
        )?;

        apply_one_to_one(
            &preset_files.skills,
            "skills",
            &github_dir.join("skills"),
            ".github/skills",
            &mut result,
            conflict_mode,
            None,
            None,
        )?;

        Ok(result)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::TempDir;

    fn create_test_adapter() -> (TempDir, CopilotAdapter) {
        let temp_dir = TempDir::new().unwrap();
        let adapter = CopilotAdapter::new(temp_dir.path());
        (temp_dir, adapter)
    }

    #[test]
    fn test_adapter_name() {
        let (_temp_dir, adapter) = create_test_adapter();
        assert_eq!(adapter.name(), "GitHub Copilot");
    }

    #[test]
    fn test_detect_no_github_dir() {
        let (temp_dir, _adapter) = create_test_adapter();
        // Verify no github/copilot files exist
        assert!(!temp_dir.path().join(".github").exists());
        assert!(!temp_dir.path().join(".vscode").exists());
    }

    #[test]
    fn test_detect_with_github_dir() {
        let (temp_dir, adapter) = create_test_adapter();
        fs::create_dir_all(temp_dir.path().join(".github")).unwrap();
        assert!(adapter.detect());
    }

    #[test]
    fn test_detect_with_vscode_dir() {
        let (temp_dir, adapter) = create_test_adapter();
        fs::create_dir_all(temp_dir.path().join(".vscode")).unwrap();
        assert!(adapter.detect());
    }

    #[test]
    fn test_detect_with_copilot_instructions() {
        let (temp_dir, adapter) = create_test_adapter();
        fs::create_dir_all(temp_dir.path().join(".github")).unwrap();
        fs::write(
            temp_dir.path().join(".github/copilot-instructions.md"),
            "# Instructions",
        )
        .unwrap();
        assert!(adapter.detect());
    }

    #[test]
    fn test_apply_rules() {
        let (temp_dir, adapter) = create_test_adapter();

        let preset_files = PresetFiles {
            rules: vec![PresetFile {
                relative_path: "rules/code-style.md".to_string(),
                content: "# Code Style".to_string(),
            }],
            ..Default::default()
        };

        let result = adapter
            .apply(&preset_files, temp_dir.path(), &mut ConflictMode::Force)
            .unwrap();

        assert!(!result.created.is_empty());

        // rules/code-style.md → .github/instructions/code-style.instructions.md
        let instruction_file = temp_dir
            .path()
            .join(".github/instructions/code-style.instructions.md");
        assert!(instruction_file.exists());
        let content = fs::read_to_string(instruction_file).unwrap();
        assert!(content.contains("# Code Style"));
    }

    #[test]
    fn test_apply_rules_converts_globs_to_apply_to() {
        let (temp_dir, adapter) = create_test_adapter();

        let preset_files = PresetFiles {
            rules: vec![PresetFile {
                relative_path: "rules/rust.md".to_string(),
                content: "---\ndescription: Rust rules\nglobs: \"**/*.rs\"\n---\n# Rust Rules"
                    .to_string(),
            }],
            ..Default::default()
        };

        adapter
            .apply(&preset_files, temp_dir.path(), &mut ConflictMode::Force)
            .unwrap();

        let file = temp_dir
            .path()
            .join(".github/instructions/rust.instructions.md");
        let content = fs::read_to_string(file).unwrap();

        // Verify globs -> applyTo conversion
        assert!(content.contains("applyTo:"));
        assert!(!content.contains("globs:"));
        assert!(content.contains("# Rust Rules"));
    }

    #[test]
    fn test_apply_rules_no_frontmatter_unchanged() {
        let (temp_dir, adapter) = create_test_adapter();

        let preset_files = PresetFiles {
            rules: vec![PresetFile {
                relative_path: "rules/general.md".to_string(),
                content: "# General Rules\n\nNo frontmatter here.".to_string(),
            }],
            ..Default::default()
        };

        adapter
            .apply(&preset_files, temp_dir.path(), &mut ConflictMode::Force)
            .unwrap();

        let file = temp_dir
            .path()
            .join(".github/instructions/general.instructions.md");
        let content = fs::read_to_string(file).unwrap();

        assert_eq!(content, "# General Rules\n\nNo frontmatter here.");
    }

    #[test]
    fn test_apply_rules_multiple() {
        let (temp_dir, adapter) = create_test_adapter();

        let preset_files = PresetFiles {
            rules: vec![
                PresetFile {
                    relative_path: "rules/code-style.md".to_string(),
                    content: "# Code Style".to_string(),
                },
                PresetFile {
                    relative_path: "rules/security.md".to_string(),
                    content: "# Security".to_string(),
                },
            ],
            ..Default::default()
        };

        let result = adapter
            .apply(&preset_files, temp_dir.path(), &mut ConflictMode::Force)
            .unwrap();

        assert_eq!(result.created.len(), 2);
        assert!(temp_dir
            .path()
            .join(".github/instructions/code-style.instructions.md")
            .exists());
        assert!(temp_dir
            .path()
            .join(".github/instructions/security.instructions.md")
            .exists());
    }

    #[test]
    fn test_apply_rules_existing() {
        let (temp_dir, adapter) = create_test_adapter();

        // Create existing file
        let instructions_dir = temp_dir.path().join(".github/instructions");
        fs::create_dir_all(&instructions_dir).unwrap();
        fs::write(
            instructions_dir.join("existing.instructions.md"),
            "# Old Rules",
        )
        .unwrap();

        let preset_files = PresetFiles {
            rules: vec![PresetFile {
                relative_path: "rules/existing.md".to_string(),
                content: "# New Rules".to_string(),
            }],
            ..Default::default()
        };

        let result = adapter
            .apply(&preset_files, temp_dir.path(), &mut ConflictMode::Force)
            .unwrap();

        assert!(result
            .updated
            .iter()
            .any(|f| f.contains("existing.instructions.md")));
    }

    #[test]
    fn test_apply_commands() {
        let (temp_dir, adapter) = create_test_adapter();

        let preset_files = PresetFiles {
            commands: vec![PresetFile {
                relative_path: "commands/build.md".to_string(),
                content: "# Build Command".to_string(),
            }],
            ..Default::default()
        };

        let result = adapter
            .apply(&preset_files, temp_dir.path(), &mut ConflictMode::Force)
            .unwrap();

        assert!(result
            .created
            .iter()
            .any(|f: &String| f.contains("build.prompt.md")));

        let prompt_file = temp_dir.path().join(".github/prompts/build.prompt.md");
        assert!(prompt_file.exists());
    }

    #[test]
    fn test_scan() {
        let (_temp_dir, adapter) = create_test_adapter();

        let preset_files = PresetFiles {
            rules: vec![PresetFile {
                relative_path: "rules/test.md".to_string(),
                content: "# Test".to_string(),
            }],
            ..Default::default()
        };

        let result = adapter.scan(&preset_files, Path::new("."));

        assert!(result.has_changes());
        assert!(!result.has_conflicts());
        // Verify scan results use .github/instructions/ path
        assert_eq!(
            result.changes[0].path,
            ".github/instructions/test.instructions.md"
        );
    }

    #[test]
    fn test_scan_conflicts() {
        let (temp_dir, adapter) = create_test_adapter();

        // Create existing file in .github/instructions/
        let instructions_dir = temp_dir.path().join(".github/instructions");
        fs::create_dir_all(&instructions_dir).unwrap();
        fs::write(instructions_dir.join("new.instructions.md"), "existing").unwrap();

        let preset_files = PresetFiles {
            rules: vec![PresetFile {
                relative_path: "rules/new.md".to_string(),
                content: "# New".to_string(),
            }],
            ..Default::default()
        };

        let result = adapter.scan(&preset_files, temp_dir.path());

        assert!(result.has_conflicts());
    }

    #[test]
    fn test_apply_memory() {
        let (temp_dir, adapter) = create_test_adapter();

        let preset_files = PresetFiles {
            memory: vec![PresetFile {
                relative_path: "memory/context.md".to_string(),
                content: "# Project Context".to_string(),
            }],
            ..Default::default()
        };

        adapter
            .apply(&preset_files, temp_dir.path(), &mut ConflictMode::Force)
            .unwrap();

        let instructions = temp_dir.path().join(".github/copilot-instructions.md");
        assert!(instructions.exists());
        let content = fs::read_to_string(instructions).unwrap();
        assert!(content.contains("# Project Context"));
    }
}
