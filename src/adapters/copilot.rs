use super::traits::{ApplyResult, ConflictMode, PreviewResult, TemplateFile, TemplateFiles, ToolAdapter, write_with_conflict};
use crate::error::Result;
use crate::template::config::MergeStrategy;
use std::fs;
use std::path::{Path, PathBuf};

/// GitHub Copilot adapter
///
/// Converts templates to GitHub Copilot format:
/// - rules/*.md → .github/copilot-instructions.md (merged)
/// - memory/*.md → .github/copilot-instructions.md (appended)
/// - commands/*.md → .github/prompts/*.prompt.md
/// - agents/*.md → .github/agents/*.agent.md
/// - skills/*.ts → .github/skills/ or .claude/skills/ (shared)
/// - mcp/*.json → .vscode/mcp.json
pub struct CopilotAdapter {
    project_dir: PathBuf,
}

impl CopilotAdapter {
    pub fn new(project_dir: &Path) -> Self {
        Self {
            project_dir: project_dir.to_path_buf(),
        }
    }

    /// Get the .github directory path
    fn github_dir(&self) -> PathBuf {
        self.project_dir.join(".github")
    }

    /// Get the .vscode directory path
    fn vscode_dir(&self) -> PathBuf {
        self.project_dir.join(".vscode")
    }

    /// Get the copilot-instructions.md file path
    fn copilot_instructions_file(&self) -> PathBuf {
        self.github_dir().join("copilot-instructions.md")
    }

    /// Ensure .github directory exists
    fn ensure_github_dir(&self) -> Result<()> {
        let github_dir = self.github_dir();
        if !github_dir.exists() {
            fs::create_dir_all(&github_dir)?;
        }
        Ok(())
    }

    /// Ensure .vscode directory exists
    fn ensure_vscode_dir(&self) -> Result<()> {
        let vscode_dir = self.vscode_dir();
        if !vscode_dir.exists() {
            fs::create_dir_all(&vscode_dir)?;
        }
        Ok(())
    }

    /// Apply rules files: rules/*.md → .github/copilot-instructions.md (merged or replaced)
    fn apply_rules(&self, files: &[TemplateFile], strategy: &MergeStrategy, result: &mut ApplyResult, mode: &mut ConflictMode) -> Result<()> {
        if files.is_empty() {
            return Ok(());
        }

        let instructions_file = self.copilot_instructions_file();

        // Build template content
        let mut template_content = String::new();
        template_content.push_str("# GitHub Copilot Instructions\n\n");
        template_content.push_str("<!-- Generated by aidot - DO NOT EDIT MANUALLY -->\n\n");

        for (i, file) in files.iter().enumerate() {
            if i > 0 {
                template_content.push_str("\n\n---\n\n");
            }
            template_content.push_str(&format!("## {}\n\n", file.relative_path.replace("rules/", "").replace(".md", "")));
            template_content.push_str(&file.content);
        }

        match strategy {
            MergeStrategy::Concat => {
                // Concat always merges without conflict prompt
                let content = if instructions_file.exists() {
                    let existing = fs::read_to_string(&instructions_file)?;
                    format!("{}\n\n---\n\n{}", existing, template_content)
                } else {
                    template_content
                };

                if instructions_file.exists() {
                    fs::write(&instructions_file, content)?;
                    result.add_updated(".github/copilot-instructions.md".to_string());
                } else {
                    fs::write(&instructions_file, content)?;
                    result.add_created(".github/copilot-instructions.md".to_string());
                }
            }
            MergeStrategy::Replace => {
                // Replace may trigger conflict resolution
                *mode = write_with_conflict(&instructions_file, &template_content, *mode, result, ".github/copilot-instructions.md")?;
            }
        }

        Ok(())
    }

    /// Apply memory files: memory/*.md → .github/copilot-instructions.md (appended or replaced)
    fn apply_memory(&self, files: &[TemplateFile], strategy: &MergeStrategy, result: &mut ApplyResult, mode: &mut ConflictMode) -> Result<()> {
        if files.is_empty() {
            return Ok(());
        }

        let instructions_file = self.copilot_instructions_file();

        // Build memory content
        let mut memory_content = String::from("\n\n---\n\n## Project Context\n\n");
        for (i, file) in files.iter().enumerate() {
            if i > 0 {
                memory_content.push_str("\n\n---\n\n");
            }
            memory_content.push_str(&format!("### {}\n\n", file.relative_path.replace("memory/", "").replace(".md", "")));
            memory_content.push_str(&file.content);
        }

        match strategy {
            MergeStrategy::Concat => {
                // Concat always merges without conflict prompt
                let base = if instructions_file.exists() {
                    fs::read_to_string(&instructions_file)?
                } else {
                    String::from("# GitHub Copilot Instructions\n\n<!-- Generated by aidot -->\n")
                };
                let content = format!("{}{}", base, memory_content);
                fs::write(&instructions_file, content)?;
                result.add_updated(".github/copilot-instructions.md".to_string());
            }
            MergeStrategy::Replace => {
                // Replace may trigger conflict resolution
                let content = format!("# GitHub Copilot Instructions\n\n<!-- Generated by aidot -->\n{}", memory_content);
                *mode = write_with_conflict(&instructions_file, &content, *mode, result, ".github/copilot-instructions.md")?;
            }
        }

        Ok(())
    }

    /// Apply commands: commands/*.md → .github/prompts/*.prompt.md
    fn apply_commands(&self, files: &[TemplateFile], result: &mut ApplyResult, mode: &mut ConflictMode) -> Result<()> {
        if files.is_empty() {
            return Ok(());
        }

        let prompts_dir = self.github_dir().join("prompts");
        fs::create_dir_all(&prompts_dir)?;

        for file in files {
            // Convert filename: command-name.md → command-name.prompt.md
            let original_name = file.relative_path.replace("commands/", "");
            let prompt_name = if original_name.ends_with(".md") {
                original_name.replace(".md", ".prompt.md")
            } else {
                format!("{}.prompt.md", original_name)
            };

            let target_path = prompts_dir.join(&prompt_name);
            let display_path = format!(".github/prompts/{}", prompt_name);

            *mode = write_with_conflict(&target_path, &file.content, *mode, result, &display_path)?;
        }

        Ok(())
    }

    /// Apply MCP configs: mcp/*.json → .vscode/mcp.json
    fn apply_mcp(&self, files: &[TemplateFile], strategy: &MergeStrategy, result: &mut ApplyResult, mode: &mut ConflictMode) -> Result<()> {
        if files.is_empty() {
            return Ok(());
        }

        self.ensure_vscode_dir()?;
        let mcp_file = self.vscode_dir().join("mcp.json");

        match strategy {
            MergeStrategy::Concat => {
                // Concat always merges without conflict prompt
                let mut mcp_config: serde_json::Value = if mcp_file.exists() {
                    let content = fs::read_to_string(&mcp_file)?;
                    serde_json::from_str(&content)?
                } else {
                    serde_json::json!({
                        "inputs": [],
                        "servers": {}
                    })
                };

                // Ensure servers object exists
                if mcp_config.get("servers").is_none() {
                    mcp_config["servers"] = serde_json::json!({});
                }

                // Merge MCP configurations
                for file in files {
                    let server_config: serde_json::Value = serde_json::from_str(&file.content)?;
                    let server_name = file.relative_path
                        .replace("mcp/", "")
                        .replace(".json", "");
                    mcp_config["servers"][server_name] = server_config;
                }

                let json_str = serde_json::to_string_pretty(&mcp_config)?;
                fs::write(&mcp_file, json_str)?;
                result.add_updated(".vscode/mcp.json".to_string());
            }
            MergeStrategy::Replace => {
                // Replace may trigger conflict resolution
                let mut mcp_config = serde_json::json!({
                    "inputs": [],
                    "servers": {}
                });

                for file in files {
                    let server_config: serde_json::Value = serde_json::from_str(&file.content)?;
                    let server_name = file.relative_path
                        .replace("mcp/", "")
                        .replace(".json", "");
                    mcp_config["servers"][server_name] = server_config;
                }

                let json_str = serde_json::to_string_pretty(&mcp_config)?;
                *mode = write_with_conflict(&mcp_file, &json_str, *mode, result, ".vscode/mcp.json")?;
            }
        }

        Ok(())
    }

    /// Apply agents: agents/*.md → .github/agents/*.agent.md
    fn apply_agents(&self, files: &[TemplateFile], result: &mut ApplyResult, mode: &mut ConflictMode) -> Result<()> {
        if files.is_empty() {
            return Ok(());
        }

        let agents_dir = self.github_dir().join("agents");
        fs::create_dir_all(&agents_dir)?;

        for file in files {
            // Convert filename: agent-name.md → agent-name.agent.md
            let original_name = file.relative_path.replace("agents/", "");
            let agent_name = if original_name.ends_with(".md") {
                original_name.replace(".md", ".agent.md")
            } else {
                format!("{}.agent.md", original_name)
            };

            let target_path = agents_dir.join(&agent_name);
            let display_path = format!(".github/agents/{}", agent_name);

            *mode = write_with_conflict(&target_path, &file.content, *mode, result, &display_path)?;
        }

        Ok(())
    }

    /// Apply skills: skills/*.ts → .github/skills/
    fn apply_skills(&self, files: &[TemplateFile], result: &mut ApplyResult, mode: &mut ConflictMode) -> Result<()> {
        if files.is_empty() {
            return Ok(());
        }

        let skills_dir = self.github_dir().join("skills");
        fs::create_dir_all(&skills_dir)?;

        for file in files {
            let filename = file.relative_path.replace("skills/", "");
            let target_path = skills_dir.join(&filename);
            let display_path = format!(".github/skills/{}", filename);

            *mode = write_with_conflict(&target_path, &file.content, *mode, result, &display_path)?;
        }

        Ok(())
    }
}

impl ToolAdapter for CopilotAdapter {
    fn name(&self) -> &str {
        "GitHub Copilot"
    }

    fn detect(&self) -> bool {
        // Check if .github/copilot-instructions.md exists
        if self.copilot_instructions_file().exists() {
            return true;
        }

        // Check if .github/instructions/ directory exists
        let instructions_dir = self.github_dir().join("instructions");
        if instructions_dir.exists() {
            return true;
        }

        // Check if .github directory exists (likely a GitHub project)
        if self.github_dir().exists() {
            return true;
        }

        // Check if .vscode directory exists (VS Code project, might use Copilot)
        if self.vscode_dir().exists() {
            return true;
        }

        false
    }

    fn apply(
        &self,
        template_files: &TemplateFiles,
        _target_dir: &Path,
        conflict_mode: ConflictMode,
    ) -> Result<ApplyResult> {
        self.ensure_github_dir()?;

        let mut result = ApplyResult::new();
        let mut mode = conflict_mode;

        // Apply each section with their merge strategies
        self.apply_rules(&template_files.rules, &template_files.rules_strategy, &mut result, &mut mode)?;
        self.apply_memory(&template_files.memory, &template_files.memory_strategy, &mut result, &mut mode)?;
        self.apply_commands(&template_files.commands, &mut result, &mut mode)?;
        self.apply_mcp(&template_files.mcp, &template_files.mcp_strategy, &mut result, &mut mode)?;
        self.apply_agents(&template_files.agents, &mut result, &mut mode)?;
        self.apply_skills(&template_files.skills, &mut result, &mut mode)?;
        // Note: hooks and settings are not directly applicable to Copilot

        Ok(result)
    }

    fn preview(
        &self,
        template_files: &TemplateFiles,
        _target_dir: &Path,
        conflict_mode: ConflictMode,
    ) -> PreviewResult {
        let mut result = PreviewResult::new();
        let instructions_file = self.copilot_instructions_file();
        let mcp_file = self.vscode_dir().join("mcp.json");
        let skip_existing = conflict_mode == ConflictMode::Skip;

        // Rules → .github/copilot-instructions.md
        if !template_files.rules.is_empty() {
            if instructions_file.exists() {
                if skip_existing {
                    result.add_would_skip(".github/copilot-instructions.md".to_string());
                } else {
                    result.add_would_update(".github/copilot-instructions.md".to_string(), "rules".to_string());
                }
            } else {
                result.add_would_create(".github/copilot-instructions.md".to_string(), "rules".to_string());
            }
        }

        // Memory → .github/copilot-instructions.md (appended)
        if !template_files.memory.is_empty() {
            if instructions_file.exists() && skip_existing {
                result.add_would_skip(".github/copilot-instructions.md".to_string());
            } else {
                result.add_would_update(".github/copilot-instructions.md".to_string(), "memory".to_string());
            }
        }

        // Commands → .github/prompts/*.prompt.md
        for file in &template_files.commands {
            let original_name = file.relative_path.replace("commands/", "");
            let prompt_name = if original_name.ends_with(".md") {
                original_name.replace(".md", ".prompt.md")
            } else {
                format!("{}.prompt.md", original_name)
            };
            let target = format!(".github/prompts/{}", prompt_name);
            let target_path = self.github_dir().join("prompts").join(&prompt_name);
            if target_path.exists() {
                if skip_existing {
                    result.add_would_skip(target);
                } else {
                    result.add_would_update(target, "commands".to_string());
                }
            } else {
                result.add_would_create(target, "commands".to_string());
            }
        }

        // MCP → .vscode/mcp.json
        if !template_files.mcp.is_empty() {
            if mcp_file.exists() {
                if skip_existing {
                    result.add_would_skip(".vscode/mcp.json".to_string());
                } else {
                    result.add_would_update(".vscode/mcp.json".to_string(), "mcp".to_string());
                }
            } else {
                result.add_would_create(".vscode/mcp.json".to_string(), "mcp".to_string());
            }
        }

        // Agents → .github/agents/*.agent.md
        for file in &template_files.agents {
            let original_name = file.relative_path.replace("agents/", "");
            let agent_name = if original_name.ends_with(".md") {
                original_name.replace(".md", ".agent.md")
            } else {
                format!("{}.agent.md", original_name)
            };
            let target = format!(".github/agents/{}", agent_name);
            let target_path = self.github_dir().join("agents").join(&agent_name);
            if target_path.exists() {
                if skip_existing {
                    result.add_would_skip(target);
                } else {
                    result.add_would_update(target, "agents".to_string());
                }
            } else {
                result.add_would_create(target, "agents".to_string());
            }
        }

        // Skills → .github/skills/
        for file in &template_files.skills {
            let filename = file.relative_path.replace("skills/", "");
            let target = format!(".github/skills/{}", filename);
            let target_path = self.github_dir().join("skills").join(&filename);
            if target_path.exists() {
                if skip_existing {
                    result.add_would_skip(target);
                } else {
                    result.add_would_update(target, "skills".to_string());
                }
            } else {
                result.add_would_create(target, "skills".to_string());
            }
        }

        result
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::TempDir;

    fn create_test_adapter() -> (TempDir, CopilotAdapter) {
        let temp_dir = TempDir::new().unwrap();
        let adapter = CopilotAdapter::new(temp_dir.path());
        (temp_dir, adapter)
    }

    #[test]
    fn test_adapter_name() {
        let (_temp_dir, adapter) = create_test_adapter();
        assert_eq!(adapter.name(), "GitHub Copilot");
    }

    #[test]
    fn test_detect_no_github_dir() {
        let (temp_dir, _adapter) = create_test_adapter();
        // Verify no github/copilot files exist
        assert!(!temp_dir.path().join(".github").exists());
        assert!(!temp_dir.path().join(".vscode").exists());
    }

    #[test]
    fn test_detect_with_github_dir() {
        let (temp_dir, adapter) = create_test_adapter();
        fs::create_dir_all(temp_dir.path().join(".github")).unwrap();
        assert!(adapter.detect());
    }

    #[test]
    fn test_detect_with_vscode_dir() {
        let (temp_dir, adapter) = create_test_adapter();
        fs::create_dir_all(temp_dir.path().join(".vscode")).unwrap();
        assert!(adapter.detect());
    }

    #[test]
    fn test_detect_with_copilot_instructions() {
        let (temp_dir, adapter) = create_test_adapter();
        fs::create_dir_all(temp_dir.path().join(".github")).unwrap();
        fs::write(
            temp_dir.path().join(".github/copilot-instructions.md"),
            "# Instructions",
        )
        .unwrap();
        assert!(adapter.detect());
    }

    #[test]
    fn test_apply_rules() {
        let (temp_dir, adapter) = create_test_adapter();

        let template_files = TemplateFiles {
            rules: vec![TemplateFile {
                relative_path: "rules/code-style.md".to_string(),
                content: "# Code Style".to_string(),
            }],
            ..Default::default()
        };

        let result = adapter.apply(&template_files, temp_dir.path(), ConflictMode::Force).unwrap();

        assert!(!result.created.is_empty() || !result.updated.is_empty());

        let instructions = temp_dir.path().join(".github/copilot-instructions.md");
        assert!(instructions.exists());
        let content = fs::read_to_string(instructions).unwrap();
        assert!(content.contains("# Code Style"));
    }

    #[test]
    fn test_apply_rules_concat_strategy() {
        let (temp_dir, adapter) = create_test_adapter();

        // Create existing instructions
        fs::create_dir_all(temp_dir.path().join(".github")).unwrap();
        fs::write(
            temp_dir.path().join(".github/copilot-instructions.md"),
            "# Existing Instructions",
        )
        .unwrap();

        let template_files = TemplateFiles {
            rules: vec![TemplateFile {
                relative_path: "rules/new.md".to_string(),
                content: "# New Rules".to_string(),
            }],
            rules_strategy: MergeStrategy::Concat,
            ..Default::default()
        };

        adapter.apply(&template_files, temp_dir.path(), ConflictMode::Force).unwrap();

        let content = fs::read_to_string(
            temp_dir.path().join(".github/copilot-instructions.md"),
        )
        .unwrap();
        assert!(content.contains("# Existing Instructions"));
        assert!(content.contains("# New Rules"));
    }

    #[test]
    fn test_apply_rules_replace_strategy() {
        let (temp_dir, adapter) = create_test_adapter();

        // Create existing instructions
        fs::create_dir_all(temp_dir.path().join(".github")).unwrap();
        fs::write(
            temp_dir.path().join(".github/copilot-instructions.md"),
            "# Old Instructions",
        )
        .unwrap();

        let template_files = TemplateFiles {
            rules: vec![TemplateFile {
                relative_path: "rules/new.md".to_string(),
                content: "# New Only".to_string(),
            }],
            rules_strategy: MergeStrategy::Replace,
            ..Default::default()
        };

        adapter.apply(&template_files, temp_dir.path(), ConflictMode::Force).unwrap();

        let content = fs::read_to_string(
            temp_dir.path().join(".github/copilot-instructions.md"),
        )
        .unwrap();
        assert!(!content.contains("# Old Instructions"));
        assert!(content.contains("# New Only"));
    }

    #[test]
    fn test_apply_commands() {
        let (temp_dir, adapter) = create_test_adapter();

        let template_files = TemplateFiles {
            commands: vec![TemplateFile {
                relative_path: "commands/build.md".to_string(),
                content: "# Build Command".to_string(),
            }],
            ..Default::default()
        };

        let result = adapter.apply(&template_files, temp_dir.path(), ConflictMode::Force).unwrap();

        assert!(result.created.iter().any(|f: &String| f.contains("build.prompt.md")));

        let prompt_file = temp_dir.path().join(".github/prompts/build.prompt.md");
        assert!(prompt_file.exists());
    }

    #[test]
    fn test_preview() {
        let (_temp_dir, adapter) = create_test_adapter();

        let template_files = TemplateFiles {
            rules: vec![TemplateFile {
                relative_path: "rules/test.md".to_string(),
                content: "# Test".to_string(),
            }],
            ..Default::default()
        };

        let result = adapter.preview(&template_files, Path::new("."), ConflictMode::Force);

        assert!(result.has_changes());
    }

    #[test]
    fn test_apply_memory() {
        let (temp_dir, adapter) = create_test_adapter();

        let template_files = TemplateFiles {
            memory: vec![TemplateFile {
                relative_path: "memory/context.md".to_string(),
                content: "# Project Context".to_string(),
            }],
            ..Default::default()
        };

        adapter.apply(&template_files, temp_dir.path(), ConflictMode::Force).unwrap();

        let instructions = temp_dir.path().join(".github/copilot-instructions.md");
        assert!(instructions.exists());
        let content = fs::read_to_string(instructions).unwrap();
        assert!(content.contains("# Project Context"));
    }
}
