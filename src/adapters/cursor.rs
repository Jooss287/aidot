use super::common::{
    apply_json_merge, apply_one_to_one, ensure_dir, scan_merged_section, scan_one_to_one,
};
use super::conflict::{write_with_conflict, ConflictMode};
use super::helpers::{has_frontmatter, is_command_available, strip_section_prefix};
use super::traits::{ApplyResult, PresetFile, PresetFiles, ScanResult, ToolAdapter};
use crate::error::Result;
use std::fs;
use std::path::{Path, PathBuf};

/// Cursor adapter
///
/// Converts presets to Cursor format:
/// - rules/*.md → .cursor/rules/*.md or *.mdc (frontmatter → .mdc, otherwise → .md)
/// - memory/*.md → .cursorrules (appended)
/// - commands/*.md → .cursor/commands/
/// - mcp/*.json → .cursor/mcp.json (mcpServers section)
/// - hooks/*.json → .cursor/hooks.json
/// - agents/*.md → .cursor/agents/
/// - skills/*.ts → .cursor/skills/
pub struct CursorAdapter {
    project_dir: PathBuf,
}

impl CursorAdapter {
    pub fn new(project_dir: &Path) -> Self {
        Self {
            project_dir: project_dir.to_path_buf(),
        }
    }

    /// Get the .cursor directory path
    fn cursor_dir(&self) -> PathBuf {
        self.project_dir.join(".cursor")
    }

    /// Get the .cursorrules file path
    fn cursorrules_file(&self) -> PathBuf {
        self.project_dir.join(".cursorrules")
    }

    /// Determine the target filename for a rule file based on frontmatter presence.
    /// Files with YAML frontmatter get .mdc extension, others keep .md.
    fn rule_filename(name: &str, content: &str) -> String {
        if has_frontmatter(content) {
            if let Some(stem) = name.strip_suffix(".md") {
                format!("{}.mdc", stem)
            } else {
                name.to_string()
            }
        } else {
            name.to_string()
        }
    }

    /// Apply memory files: memory/*.md → .cursorrules (appended)
    fn apply_memory(
        &self,
        files: &[PresetFile],
        result: &mut ApplyResult,
        mode: &mut ConflictMode,
    ) -> Result<()> {
        if files.is_empty() {
            return Ok(());
        }

        let cursorrules = self.cursorrules_file();

        // Build memory content
        let mut memory_content = String::from("\n\n---\n\n# Project Memory\n\n");
        for (i, file) in files.iter().enumerate() {
            if i > 0 {
                memory_content.push_str("\n\n---\n\n");
            }
            memory_content.push_str(&format!(
                "## {}\n\n",
                strip_section_prefix(&file.relative_path, "memory").replace(".md", "")
            ));
            memory_content.push_str(&file.content);
        }

        // Read existing content or create header
        let base = if cursorrules.exists() {
            fs::read_to_string(&cursorrules)?
        } else {
            String::from("# Cursor Rules\n# Generated by aidot\n")
        };
        let content = format!("{}{}", base, memory_content);

        write_with_conflict(&cursorrules, &content, mode, result, ".cursorrules")?;

        Ok(())
    }

    /// Apply hooks: hooks/*.json → .cursor/hooks.json
    fn apply_hooks(
        &self,
        files: &[PresetFile],
        result: &mut ApplyResult,
        mode: &mut ConflictMode,
    ) -> Result<()> {
        if files.is_empty() {
            return Ok(());
        }

        let hooks_file = self.cursor_dir().join("hooks.json");

        // Merge all hooks into one JSON object with standard structure
        let mut hooks_config = serde_json::json!({
            "version": 1,
            "hooks": {}
        });

        for file in files {
            let hook_config: serde_json::Value = serde_json::from_str(&file.content)?;
            let hook_name = strip_section_prefix(&file.relative_path, "hooks").replace(".json", "");

            // Add to hooks object
            if let Some(hooks_obj) = hooks_config.get_mut("hooks") {
                hooks_obj[hook_name] = hook_config;
            }
        }

        let json_str = serde_json::to_string_pretty(&hooks_config)?;
        write_with_conflict(&hooks_file, &json_str, mode, result, ".cursor/hooks.json")?;

        Ok(())
    }
}

impl ToolAdapter for CursorAdapter {
    fn name(&self) -> &str {
        "Cursor"
    }

    fn detect(&self) -> bool {
        self.cursorrules_file().exists()
            || self.cursor_dir().exists()
            || is_command_available("cursor")
    }

    fn scan(&self, preset_files: &PresetFiles, _target_dir: &Path) -> ScanResult {
        let mut result = ScanResult::new();
        let cursor_dir = self.cursor_dir();
        let mcp_file = cursor_dir.join("mcp.json");

        // Rules with frontmatter-aware filename transform
        let rule_fn = |n: &str, c: &str| Self::rule_filename(n, c);
        scan_one_to_one(
            &preset_files.rules,
            "rules",
            &cursor_dir.join("rules"),
            ".cursor/rules",
            &mut result,
            Some(&rule_fn),
            None,
        );

        // Memory → .cursorrules (appended)
        if !preset_files.memory.is_empty() {
            result.add_change(
                ".cursorrules".to_string(),
                "memory".to_string(),
                self.cursorrules_file().exists(),
            );
        }

        // 1:1 sections
        scan_one_to_one(
            &preset_files.commands,
            "commands",
            &cursor_dir.join("commands"),
            ".cursor/commands",
            &mut result,
            None,
            None,
        );
        scan_one_to_one(
            &preset_files.agents,
            "agents",
            &cursor_dir.join("agents"),
            ".cursor/agents",
            &mut result,
            None,
            None,
        );
        scan_one_to_one(
            &preset_files.skills,
            "skills",
            &cursor_dir.join("skills"),
            ".cursor/skills",
            &mut result,
            None,
            None,
        );

        // Merged sections
        scan_merged_section(
            &preset_files.mcp,
            ".cursor/mcp.json",
            "mcp",
            &mcp_file,
            &mut result,
        );
        scan_merged_section(
            &preset_files.hooks,
            ".cursor/hooks.json",
            "hooks",
            &cursor_dir.join("hooks.json"),
            &mut result,
        );

        result
    }

    fn apply(
        &self,
        preset_files: &PresetFiles,
        _target_dir: &Path,
        conflict_mode: &mut ConflictMode,
    ) -> Result<ApplyResult> {
        ensure_dir(&self.cursor_dir())?;

        let mut result = ApplyResult::new();
        let cursor_dir = self.cursor_dir();

        // Apply merged sections first (may trigger interactive prompts)
        self.apply_memory(&preset_files.memory, &mut result, conflict_mode)?;
        apply_json_merge(
            &preset_files.mcp,
            "mcp",
            &cursor_dir.join("mcp.json"),
            ".cursor/mcp.json",
            "mcpServers",
            serde_json::json!({}),
            &mut result,
            conflict_mode,
        )?;
        self.apply_hooks(&preset_files.hooks, &mut result, conflict_mode)?;

        // 1:1 mapped sections (resolved immediately from PreResolved map)
        let rule_fn = |n: &str, c: &str| Self::rule_filename(n, c);
        apply_one_to_one(
            &preset_files.rules,
            "rules",
            &cursor_dir.join("rules"),
            ".cursor/rules",
            &mut result,
            conflict_mode,
            Some(&rule_fn),
            None,
        )?;
        apply_one_to_one(
            &preset_files.commands,
            "commands",
            &cursor_dir.join("commands"),
            ".cursor/commands",
            &mut result,
            conflict_mode,
            None,
            None,
        )?;
        apply_one_to_one(
            &preset_files.agents,
            "agents",
            &cursor_dir.join("agents"),
            ".cursor/agents",
            &mut result,
            conflict_mode,
            None,
            None,
        )?;
        apply_one_to_one(
            &preset_files.skills,
            "skills",
            &cursor_dir.join("skills"),
            ".cursor/skills",
            &mut result,
            conflict_mode,
            None,
            None,
        )?;

        Ok(result)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::TempDir;

    fn create_test_adapter() -> (TempDir, CursorAdapter) {
        let temp_dir = TempDir::new().unwrap();
        let adapter = CursorAdapter::new(temp_dir.path());
        (temp_dir, adapter)
    }

    #[test]
    fn test_adapter_name() {
        let (_temp_dir, adapter) = create_test_adapter();
        assert_eq!(adapter.name(), "Cursor");
    }

    #[test]
    fn test_detect_no_cursor() {
        let (temp_dir, _adapter) = create_test_adapter();
        // Verify no cursor files exist
        assert!(!temp_dir.path().join(".cursorrules").exists());
        assert!(!temp_dir.path().join(".cursor").exists());
    }

    #[test]
    fn test_detect_with_cursorrules() {
        let (temp_dir, adapter) = create_test_adapter();
        fs::write(temp_dir.path().join(".cursorrules"), "# Rules").unwrap();
        assert!(adapter.detect());
    }

    #[test]
    fn test_detect_with_cursor_dir() {
        let (temp_dir, adapter) = create_test_adapter();
        fs::create_dir_all(temp_dir.path().join(".cursor")).unwrap();
        assert!(adapter.detect());
    }

    #[test]
    fn test_apply_rules_without_frontmatter() {
        let (temp_dir, adapter) = create_test_adapter();

        let preset_files = PresetFiles {
            rules: vec![PresetFile {
                relative_path: "rules/code-style.md".to_string(),
                content: "# Code Style".to_string(),
            }],
            ..Default::default()
        };

        let result = adapter
            .apply(&preset_files, temp_dir.path(), &mut ConflictMode::Force)
            .unwrap();

        assert!(!result.created.is_empty());

        // Without front matter, keep .md extension
        let rule_file = temp_dir.path().join(".cursor/rules/code-style.md");
        assert!(rule_file.exists());
        let content = fs::read_to_string(rule_file).unwrap();
        assert!(content.contains("# Code Style"));
    }

    #[test]
    fn test_apply_rules_with_frontmatter() {
        let (temp_dir, adapter) = create_test_adapter();

        let content_with_frontmatter =
            "---\ndescription: Code style rules\nglobs: \"**/*.rs\"\n---\n# Code Style".to_string();

        let preset_files = PresetFiles {
            rules: vec![PresetFile {
                relative_path: "rules/code-style.md".to_string(),
                content: content_with_frontmatter.clone(),
            }],
            ..Default::default()
        };

        let result = adapter
            .apply(&preset_files, temp_dir.path(), &mut ConflictMode::Force)
            .unwrap();

        assert!(!result.created.is_empty());

        // With front matter, convert to .mdc extension
        let rule_file = temp_dir.path().join(".cursor/rules/code-style.mdc");
        assert!(rule_file.exists());
        let content = fs::read_to_string(rule_file).unwrap();
        assert!(content.contains("# Code Style"));
    }

    #[test]
    fn test_apply_rules_mixed_frontmatter() {
        let (temp_dir, adapter) = create_test_adapter();

        let preset_files = PresetFiles {
            rules: vec![
                PresetFile {
                    relative_path: "rules/plain.md".to_string(),
                    content: "# Plain rule".to_string(),
                },
                PresetFile {
                    relative_path: "rules/with-meta.md".to_string(),
                    content: "---\ndescription: Meta rule\n---\n# Meta rule".to_string(),
                },
            ],
            ..Default::default()
        };

        let result = adapter
            .apply(&preset_files, temp_dir.path(), &mut ConflictMode::Force)
            .unwrap();

        assert_eq!(result.created.len(), 2);

        // plain.md -> keep .md
        assert!(temp_dir.path().join(".cursor/rules/plain.md").exists());
        // with-meta.md -> convert to .mdc
        assert!(temp_dir.path().join(".cursor/rules/with-meta.mdc").exists());
    }

    #[test]
    fn test_apply_rules_existing() {
        let (temp_dir, adapter) = create_test_adapter();

        // Create existing file
        let rules_dir = temp_dir.path().join(".cursor/rules");
        fs::create_dir_all(&rules_dir).unwrap();
        fs::write(rules_dir.join("existing.md"), "# Old Rules").unwrap();

        let preset_files = PresetFiles {
            rules: vec![PresetFile {
                relative_path: "rules/existing.md".to_string(),
                content: "# New Rules".to_string(),
            }],
            ..Default::default()
        };

        let result = adapter
            .apply(&preset_files, temp_dir.path(), &mut ConflictMode::Force)
            .unwrap();

        assert!(result
            .updated
            .iter()
            .any(|f| f.contains(".cursor/rules/existing.md")));
    }

    #[test]
    fn test_apply_commands() {
        let (temp_dir, adapter) = create_test_adapter();

        let preset_files = PresetFiles {
            commands: vec![PresetFile {
                relative_path: "commands/test.md".to_string(),
                content: "# Test Command".to_string(),
            }],
            ..Default::default()
        };

        let result = adapter
            .apply(&preset_files, temp_dir.path(), &mut ConflictMode::Force)
            .unwrap();

        assert!(result.created.iter().any(|f| f.contains("test.md")));

        let cmd_file = temp_dir.path().join(".cursor/commands/test.md");
        assert!(cmd_file.exists());
    }

    #[test]
    fn test_scan() {
        let (_temp_dir, adapter) = create_test_adapter();

        let preset_files = PresetFiles {
            rules: vec![PresetFile {
                relative_path: "rules/test.md".to_string(),
                content: "# Test".to_string(),
            }],
            ..Default::default()
        };

        let result = adapter.scan(&preset_files, Path::new("."));

        assert!(result.has_changes());
        assert!(!result.has_conflicts());
        // Verify scan results use .cursor/rules/ path
        assert!(result.changes[0].path.starts_with(".cursor/rules/"));
    }

    #[test]
    fn test_scan_with_frontmatter() {
        let (_temp_dir, adapter) = create_test_adapter();

        let preset_files = PresetFiles {
            rules: vec![PresetFile {
                relative_path: "rules/test.md".to_string(),
                content: "---\ndescription: test\n---\n# Test".to_string(),
            }],
            ..Default::default()
        };

        let result = adapter.scan(&preset_files, Path::new("."));

        assert!(result.has_changes());
        // Has front matter, so .mdc extension
        assert_eq!(result.changes[0].path, ".cursor/rules/test.mdc");
    }

    #[test]
    fn test_scan_conflicts() {
        let (temp_dir, adapter) = create_test_adapter();

        // Create existing file in .cursor/rules/
        let rules_dir = temp_dir.path().join(".cursor/rules");
        fs::create_dir_all(&rules_dir).unwrap();
        fs::write(rules_dir.join("new.md"), "existing").unwrap();

        let preset_files = PresetFiles {
            rules: vec![PresetFile {
                relative_path: "rules/new.md".to_string(),
                content: "# New".to_string(),
            }],
            ..Default::default()
        };

        let result = adapter.scan(&preset_files, temp_dir.path());

        assert!(result.has_conflicts());
    }
}
