use super::traits::{ApplyResult, PreviewResult, TemplateFile, TemplateFiles, ToolAdapter};
use crate::error::Result;
use crate::template::config::MergeStrategy;
use std::fs;
use std::path::{Path, PathBuf};

/// Cursor adapter
///
/// Converts templates to Cursor format:
/// - rules/*.md → .cursorrules (merged into single file)
/// - memory/*.md → .cursorrules (appended, with alwaysApply context)
/// - commands/*.md → .cursor/commands/
/// - mcp/*.json → .cursor/mcp.json (mcpServers section)
/// - hooks/*.json → .cursor/hooks.json
/// - agents/*.md → .cursor/agents/
/// - skills/*.ts → .cursor/skills/
pub struct CursorAdapter {
    project_dir: PathBuf,
}

impl CursorAdapter {
    pub fn new(project_dir: &Path) -> Self {
        Self {
            project_dir: project_dir.to_path_buf(),
        }
    }

    /// Get the .cursor directory path
    fn cursor_dir(&self) -> PathBuf {
        self.project_dir.join(".cursor")
    }

    /// Get the .cursorrules file path
    fn cursorrules_file(&self) -> PathBuf {
        self.project_dir.join(".cursorrules")
    }

    /// Ensure .cursor directory exists
    fn ensure_cursor_dir(&self) -> Result<()> {
        let cursor_dir = self.cursor_dir();
        if !cursor_dir.exists() {
            fs::create_dir_all(&cursor_dir)?;
        }
        Ok(())
    }

    /// Apply rules files: rules/*.md → .cursorrules (merged or replaced)
    fn apply_rules(&self, files: &[TemplateFile], strategy: &MergeStrategy, result: &mut ApplyResult) -> Result<()> {
        if files.is_empty() {
            return Ok(());
        }

        let cursorrules = self.cursorrules_file();

        // Build template content
        let mut template_content = String::new();
        template_content.push_str("# Cursor Rules\n");
        template_content.push_str("# Generated by aidot - DO NOT EDIT MANUALLY\n\n");

        for (i, file) in files.iter().enumerate() {
            if i > 0 {
                template_content.push_str("\n\n---\n\n");
            }
            template_content.push_str(&format!("# Source: {}\n\n", file.relative_path));
            template_content.push_str(&file.content);
        }

        let content = match strategy {
            MergeStrategy::Concat => {
                if cursorrules.exists() {
                    let existing = fs::read_to_string(&cursorrules)?;
                    format!("{}\n\n---\n\n{}", existing, template_content)
                } else {
                    template_content
                }
            }
            MergeStrategy::Replace => template_content,
        };

        let action = if cursorrules.exists() {
            "updated"
        } else {
            "created"
        };

        fs::write(&cursorrules, content)?;

        if action == "created" {
            result.add_created(".cursorrules".to_string());
        } else {
            result.add_updated(".cursorrules".to_string());
        }

        Ok(())
    }

    /// Apply memory files: memory/*.md → .cursorrules (appended or replaced)
    fn apply_memory(&self, files: &[TemplateFile], strategy: &MergeStrategy, result: &mut ApplyResult) -> Result<()> {
        if files.is_empty() {
            return Ok(());
        }

        let cursorrules = self.cursorrules_file();

        // Build memory content
        let mut memory_content = String::from("\n\n---\n\n# Project Memory (Always Apply)\n\n");
        for (i, file) in files.iter().enumerate() {
            if i > 0 {
                memory_content.push_str("\n\n---\n\n");
            }
            memory_content.push_str(&format!("## {}\n\n", file.relative_path.replace("memory/", "").replace(".md", "")));
            memory_content.push_str(&file.content);
        }

        let content = match strategy {
            MergeStrategy::Concat => {
                let base = if cursorrules.exists() {
                    fs::read_to_string(&cursorrules)?
                } else {
                    String::from("# Cursor Rules\n# Generated by aidot\n")
                };
                format!("{}{}", base, memory_content)
            }
            MergeStrategy::Replace => {
                format!("# Cursor Rules\n# Generated by aidot\n{}", memory_content)
            }
        };

        fs::write(&cursorrules, content)?;
        result.add_updated(".cursorrules".to_string());

        Ok(())
    }

    /// Apply commands: commands/*.md → .cursor/commands/
    fn apply_commands(&self, files: &[TemplateFile], result: &mut ApplyResult) -> Result<()> {
        if files.is_empty() {
            return Ok(());
        }

        let commands_dir = self.cursor_dir().join("commands");
        fs::create_dir_all(&commands_dir)?;

        for file in files {
            let filename = file.relative_path.replace("commands/", "");
            let target_path = commands_dir.join(&filename);

            fs::write(&target_path, &file.content)?;
            result.add_created(format!(".cursor/commands/{}", filename));
        }

        Ok(())
    }

    /// Apply MCP configs: mcp/*.json → .cursor/mcp.json (mcpServers section)
    fn apply_mcp(&self, files: &[TemplateFile], strategy: &MergeStrategy, result: &mut ApplyResult) -> Result<()> {
        if files.is_empty() {
            return Ok(());
        }

        let mcp_file = self.cursor_dir().join("mcp.json");

        // Read existing mcp.json or create new based on strategy
        let mut mcp_config: serde_json::Value = match strategy {
            MergeStrategy::Concat => {
                if mcp_file.exists() {
                    let content = fs::read_to_string(&mcp_file)?;
                    serde_json::from_str(&content)?
                } else {
                    serde_json::json!({})
                }
            }
            MergeStrategy::Replace => serde_json::json!({}),
        };

        // Ensure mcpServers object exists
        if mcp_config.get("mcpServers").is_none() {
            mcp_config["mcpServers"] = serde_json::json!({});
        }

        // Merge MCP configurations
        for file in files {
            let server_config: serde_json::Value = serde_json::from_str(&file.content)?;
            let server_name = file.relative_path
                .replace("mcp/", "")
                .replace(".json", "");

            mcp_config["mcpServers"][server_name] = server_config;
        }

        let json_str = serde_json::to_string_pretty(&mcp_config)?;
        fs::write(&mcp_file, json_str)?;

        result.add_updated(".cursor/mcp.json".to_string());

        Ok(())
    }

    /// Apply hooks: hooks/*.json → .cursor/hooks.json
    fn apply_hooks(&self, files: &[TemplateFile], result: &mut ApplyResult) -> Result<()> {
        if files.is_empty() {
            return Ok(());
        }

        let hooks_file = self.cursor_dir().join("hooks.json");

        // Merge all hooks into one JSON object with standard structure
        let mut hooks_config = serde_json::json!({
            "version": 1,
            "hooks": {}
        });

        for file in files {
            let hook_config: serde_json::Value = serde_json::from_str(&file.content)?;
            let hook_name = file.relative_path
                .replace("hooks/", "")
                .replace(".json", "");

            // Add to hooks object
            if let Some(hooks_obj) = hooks_config.get_mut("hooks") {
                hooks_obj[hook_name] = hook_config;
            }
        }

        let json_str = serde_json::to_string_pretty(&hooks_config)?;
        fs::write(&hooks_file, json_str)?;

        result.add_created(".cursor/hooks.json".to_string());

        Ok(())
    }

    /// Apply agents: agents/*.md → .cursor/agents/
    fn apply_agents(&self, files: &[TemplateFile], result: &mut ApplyResult) -> Result<()> {
        if files.is_empty() {
            return Ok(());
        }

        let agents_dir = self.cursor_dir().join("agents");
        fs::create_dir_all(&agents_dir)?;

        for file in files {
            let filename = file.relative_path.replace("agents/", "");
            let target_path = agents_dir.join(&filename);

            fs::write(&target_path, &file.content)?;
            result.add_created(format!(".cursor/agents/{}", filename));
        }

        Ok(())
    }

    /// Apply skills: skills/*.ts → .cursor/skills/
    fn apply_skills(&self, files: &[TemplateFile], result: &mut ApplyResult) -> Result<()> {
        if files.is_empty() {
            return Ok(());
        }

        let skills_dir = self.cursor_dir().join("skills");
        fs::create_dir_all(&skills_dir)?;

        for file in files {
            let filename = file.relative_path.replace("skills/", "");
            let target_path = skills_dir.join(&filename);

            fs::write(&target_path, &file.content)?;
            result.add_created(format!(".cursor/skills/{}", filename));
        }

        Ok(())
    }
}

impl ToolAdapter for CursorAdapter {
    fn name(&self) -> &str {
        "Cursor"
    }

    fn detect(&self) -> bool {
        // Check if .cursorrules file exists
        if self.cursorrules_file().exists() {
            return true;
        }

        // Check if .cursor directory exists
        if self.cursor_dir().exists() {
            return true;
        }

        // Check if cursor command exists
        #[cfg(target_os = "windows")]
        let check_cmd = std::process::Command::new("where")
            .arg("cursor")
            .output();

        #[cfg(not(target_os = "windows"))]
        let check_cmd = std::process::Command::new("which")
            .arg("cursor")
            .output();

        check_cmd.map(|output| output.status.success()).unwrap_or(false)
    }

    fn apply(
        &self,
        template_files: &TemplateFiles,
        _target_dir: &Path,
        _force: bool,
    ) -> Result<ApplyResult> {
        self.ensure_cursor_dir()?;

        let mut result = ApplyResult::new();

        // Apply each section with their merge strategies
        self.apply_rules(&template_files.rules, &template_files.rules_strategy, &mut result)?;
        self.apply_memory(&template_files.memory, &template_files.memory_strategy, &mut result)?;
        self.apply_commands(&template_files.commands, &mut result)?;
        self.apply_mcp(&template_files.mcp, &template_files.mcp_strategy, &mut result)?;
        self.apply_hooks(&template_files.hooks, &mut result)?;
        self.apply_agents(&template_files.agents, &mut result)?;
        self.apply_skills(&template_files.skills, &mut result)?;
        // Note: settings are not directly applicable to Cursor

        Ok(result)
    }

    fn preview(
        &self,
        template_files: &TemplateFiles,
        _target_dir: &Path,
    ) -> PreviewResult {
        let mut result = PreviewResult::new();
        let cursorrules = self.cursorrules_file();
        let mcp_file = self.cursor_dir().join("mcp.json");

        // Rules → .cursorrules
        if !template_files.rules.is_empty() {
            if cursorrules.exists() {
                result.add_would_update(".cursorrules".to_string(), "rules".to_string());
            } else {
                result.add_would_create(".cursorrules".to_string(), "rules".to_string());
            }
        }

        // Memory → .cursorrules (appended)
        if !template_files.memory.is_empty() {
            result.add_would_update(".cursorrules".to_string(), "memory".to_string());
        }

        // Commands
        for file in &template_files.commands {
            let filename = file.relative_path.replace("commands/", "");
            let target = format!(".cursor/commands/{}", filename);
            let target_path = self.cursor_dir().join("commands").join(&filename);
            if target_path.exists() {
                result.add_would_update(target, "commands".to_string());
            } else {
                result.add_would_create(target, "commands".to_string());
            }
        }

        // MCP
        if !template_files.mcp.is_empty() {
            if mcp_file.exists() {
                result.add_would_update(".cursor/mcp.json".to_string(), "mcp".to_string());
            } else {
                result.add_would_create(".cursor/mcp.json".to_string(), "mcp".to_string());
            }
        }

        // Hooks
        if !template_files.hooks.is_empty() {
            let hooks_file = self.cursor_dir().join("hooks.json");
            if hooks_file.exists() {
                result.add_would_update(".cursor/hooks.json".to_string(), "hooks".to_string());
            } else {
                result.add_would_create(".cursor/hooks.json".to_string(), "hooks".to_string());
            }
        }

        // Agents
        for file in &template_files.agents {
            let filename = file.relative_path.replace("agents/", "");
            let target = format!(".cursor/agents/{}", filename);
            let target_path = self.cursor_dir().join("agents").join(&filename);
            if target_path.exists() {
                result.add_would_update(target, "agents".to_string());
            } else {
                result.add_would_create(target, "agents".to_string());
            }
        }

        // Skills
        for file in &template_files.skills {
            let filename = file.relative_path.replace("skills/", "");
            let target = format!(".cursor/skills/{}", filename);
            let target_path = self.cursor_dir().join("skills").join(&filename);
            if target_path.exists() {
                result.add_would_update(target, "skills".to_string());
            } else {
                result.add_would_create(target, "skills".to_string());
            }
        }

        result
    }
}
